<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Econometrics I</title>
    <meta charset="utf-8" />
    <meta name="author" content="Marcell Granát" />
    <meta name="date" content="2022-01-01" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <script src="libs/htmlwidgets/htmlwidgets.js"></script>
    <script src="libs/d3/d3.min.js"></script>
    <script src="libs/dagre/dagre-d3.min.js"></script>
    <link href="libs/mermaid/dist/mermaid.css" rel="stylesheet" />
    <script src="libs/mermaid/dist/mermaid.slim.min.js"></script>
    <link href="libs/DiagrammeR-styles/styles.css" rel="stylesheet" />
    <script src="libs/chromatography/chromatography.js"></script>
    <script src="libs/DiagrammeR-binding/DiagrammeR.js"></script>
  </head>
  <body>
    <textarea id="source">
class: center, middle, title-slide

.title[
# Econometrics I
]
.subtitle[
## <img src="mnb_intezet.png" style="width:30.0%" />
Big Data and Data Visualisation
]
.author[
### Marcell Granát
]
.institute[
### Central Bank of Hungary &amp; .blue[John von Neumann University]
]
.date[
### 2022
]

---


&lt;style type="text/css"&gt;
.red { color: red; }
.blue { color: #378C95; }
strong { color: red; }
a { color: #378C95; font-weight: bold; }
.remark-inline-code { font-weight: 900; background-color: #a7d5e7; }
.caption { color: #378C95; font-style: italic; text-align: center; }

.content-box { 
box-sizing: content-box;
background-color: #378C95;
/* Total width: 160px + (2 * 20px) + (2 * 8px) = 216px
Total height: 80px + (2 * 20px) + (2 * 8px) = 136px
Content box width: 160px
Content box height: 80px */
}

.content-box-green {
background-color: #d9edc2;
}

.content-box-red {
background-color: #f9dbdb;
}

.fullprice {
text-decoration: line-through;
}
&lt;/style&gt;





# Today's .blue[Agenda]

### Session 1 - The OLS

1. The concept

### Session2 - Multivariate models



---

class: inverse, middle, center

# The concept

---

## What is econometrics?

&gt; "The application of **statistical and mathematical methods** to the analysis of **economic** data, with the purpose
of giving **empirical content** to economic theories and verifying them or refuting them."

--

<div id="htmlwidget-6d3c9f6cf5adc87dd662" style="width:700px;height:300px;" class="DiagrammeR html-widget"></div>
<script type="application/json" data-for="htmlwidget-6d3c9f6cf5adc87dd662">{"x":{"diagram":"\ngraph LR\n  A(Research question)-->B(Data collection)\n  A-->C(Formulate the model)\n  B-->D(Model estimation)\n  C-->D\n  D-->E(Testing the model)\n  E-.re-estimation.->D\n  E-->F(Policy decision)\n  E-->G(Prediction)\n"},"evals":[],"jsHooks":[]}</script>

--

A prominent tool: **regression** 

---

class: inverse, middle, center

# Bivariate OLS

---

## Basics of OLS

### Amsterdam house data


```r
amsterdam_house_df &lt;- read_csv("https://storage.googleapis.com/kagglesdsdata/datasets/1549462/2554162/HousingPrices-Amsterdam-August-2021.csv?X-Goog-Algorithm=GOOG4-RSA-SHA256&amp;X-Goog-Credential=gcp-kaggle-com%40kaggle-161607.iam.gserviceaccount.com%2F20221010%2Fauto%2Fstorage%2Fgoog4_request&amp;X-Goog-Date=20221010T111010Z&amp;X-Goog-Expires=259200&amp;X-Goog-SignedHeaders=host&amp;X-Goog-Signature=25efe3e6ca089c3f3a8be5653d118fe7a0167157a78a1b3e6cd07bdcd549978300bdbf77bbe1a916684a862a9908a103ac94121de3e5b2a5db7c9cc7ab52763ec477cf4954b77bfff8c341b4487c4c7c23c42237218110be4de7b4ed8f5c5241463dc05eae12ae104cd26e283f0fa2868b5b6456db67180fa6d1776f28334f3e77321cae6bac52c9548dcce531fcf853696253bf15d67305ffb1d75bf021c092e0a2ac6b88bedfe2ca991f2849aa1b679916e3d0d9506aec9bc39b794348380a0e89510de3fce6a22087f724714e575a14e6c5dfe8e6f040c8fd6ee02a1bc0da3032e4b948a34a8f3b144ae71d3b755fd709b29e2e61ef8bf95c83e8f4443f13", col_select = -1)
```




```
## # A tibble: 924 × 7
##    Address                                Zip      Price  Area  Room   Lon   Lat
##    &lt;chr&gt;                                  &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1 Blasiusstraat 8 2, Amsterdam           1091 CR 685000    64     3  4.91  52.4
##  2 Kromme Leimuidenstraat 13 H, Amsterdam 1059 EL 475000    60     3  4.85  52.3
##  3 Zaaiersweg 11 A, Amsterdam             1097 SM 850000   109     4  4.94  52.3
##  4 Tenerifestraat 40, Amsterdam           1060 TH 580000   128     6  4.79  52.3
##  5 Winterjanpad 21, Amsterdam             1036 KN 720000   138     5  4.90  52.4
##  6 De Wittenkade 134 I, Amsterdam         1051 AM 450000    53     2  4.88  52.4
##  7 Pruimenstraat 18 B, Amsterdam          1033 KM 450000    87     3  4.90  52.4
##  8 Da Costakade 32 II, Amsterdam          1053 WL 590000    80     2  4.87  52.4
##  9 Postjeskade 41 2, Amsterdam            1058 DG 399000    49     3  4.85  52.4
## 10 Van Ostadestraat 193 H, Amsterdam      1073 TM 300000    33     2  4.90  52.4
## # … with 914 more rows
```

---

### Amsterdam house data

.blue[What price do we expect, knowing the area of a given house?]

Approach: ???

&lt;img src="econometrics1_files/figure-html/unnamed-chunk-6-1.png" width="700px" height="450px" style="display: block; margin: auto;" /&gt;

---

### Amsterdam house data

.blue[What price do we expect, knowing the area of a given house?]

Approach: Let's fit a straight line.

&lt;img src="econometrics1_files/figure-html/unnamed-chunk-7-1.png" width="700px" height="450px" style="display: block; margin: auto;" /&gt;

---

### Amsterdam house data

.blue[What parameters do we have to know to draw the line?]

`$$Y_i = \beta_0 + \beta_1 \times X_i,$$`

.pull-left[

where

`$$Y_i = \text{The price of a given house}$$`

`$$\beta_0 = \text{The intercept of the line}$$`

`$$\beta_1 = \text{The slope of the line}$$`

`$$X_i = \text{The area of the given house}$$`
]

---

### Amsterdam house data

.blue[What parameters do we have to know to draw the line?]

`$$Y_i = \beta_0 + \beta_1 \times X_i + \epsilon_i,$$`

.pull-left[


where

`$$Y_i = \text{The price of a given house}$$`

`$$\beta_0 = \text{The intercept of the line}$$`

`$$\beta_1 = \text{The slope of the line}$$`

`$$X_i = \text{The area of the given house}$$`

`$$\epsilon_i = \text{The error term}$$`

]

.pull-right[

&lt;img src="econometrics_files/meme_error.JPG" width="260px" height="260px" style="display: block; margin: auto;" /&gt;

]

--

### How to choose the value of the intercept and the slope?

--

.blue[Minimize the error?]

--

The result would be a line under the points...

---

### Amsterdam house data

.blue[What parameters do we have to know to draw the line?]

`$$Y_i = \beta_0 + \beta_1 \times X_i + \epsilon_i,$$`

.pull-left[


where

`$$Y_i = \text{The price of a given house}$$`

`$$\beta_0 = \text{The intercept of the line}$$`

`$$\beta_1 = \text{The slope of the line}$$`

`$$X_i = \text{The area of the given house}$$`

`$$\epsilon_i = \text{The error term}$$`

]

.pull-right[

&lt;img src="econometrics_files/meme_error.JPG" width="260px" height="260px" style="display: block; margin: auto;" /&gt;

]

### How to choose the value of the intercept and the slope?


.blue[Minimize the squared error?]

--

Exactly, that is what OLS is about. OLS = Ordinary Least Squares

---

### Amsterdam house data

#### Let's calculate the sum of squared errors assuming two random values for the intercept and the slope


```r
b0 &lt;- 1000
b1 &lt;- 200

amsterdam_house_df %&gt;% 
  transmute(
    Price,
    Area,
    fit = b0 + Area * b1,
    e = Price - fit,
    e2 = e^2
  ) %$% 
  sum(e2, na.rm = TRUE)
```

```
## [1] 5.91045e+14
```

---

### Amsterdam house data

#### Let's transform this into a function


```r
sse &lt;- function(b0 = 1000, b1 = 200) {
  amsterdam_house_df %&gt;% 
    transmute(
      Price,
      Area,
      fit = b0 + Area * b1,
      e = Price - fit,
      e2 = e^2
    ) %$% 
    sum(e2, na.rm = TRUE)
}

sse(1000, 200)
```

```
## [1] 5.91045e+14
```

---

### Amsterdam house data

#### Let's apply the function on large set of values


```r
sse_df &lt;- crossing(
  b0 = seq(from = 0, to = 1e4, length.out = 100),
  b1 = seq(from = 0, to = 1e4, length.out = 100)
) %&gt;% 
  mutate(
    sse = map2_dbl(b0, b1, sse)
  ) %&gt;% 
  arrange(sse)

sse_df
```

```
## # A tibble: 10,000 × 3
##       b0    b1     sse
##    &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
*##  1    0  6869. 8.52e13
##  2  101. 6869. 8.52e13
##  3  202. 6869. 8.52e13
##  4  303. 6869. 8.52e13
##  5  404. 6869. 8.52e13
##  6  505. 6869. 8.52e13
##  7  606. 6869. 8.52e13
##  8  707. 6869. 8.52e13
##  9  808. 6869. 8.52e13
## 10  909. 6869. 8.52e13
## # … with 9,990 more rows
```

---

### Amsterdam house data

#### Let's apply the function on large set of values

&lt;img src="econometrics1_files/figure-html/unnamed-chunk-13-1.png" width="700px" height="450px" style="display: block; margin: auto;" /&gt;



---

### Amsterdam house data

Now we have run the function on 10,000 combination, but we are still not sure whether our solution is the best possible, or how far is it from that...

--

Fortunately, there is a much more efficient way to determine the line that produces the least squared errors

The normal equations:

`$$\sum Y_i =n \times \beta_0+\beta_1 \sum X_i$$`

`$$\sum X_i Y_i =\beta_0 \sum X_i+\beta_1 \sum X_i^2$$`

---

### Amsterdam house data

In our case:


```r
amsterdam_house_df %&gt;% 
  drop_na(Price, Area) %&gt;% 
  summarise(n = n(), y = sum(Price), x = sum(Area), 
            xz = sum(Price * Area), x2 = sum(Area^2))
```

```
## # A tibble: 1 × 5
##       n         y     x          xz       x2
##   &lt;int&gt;     &lt;dbl&gt; &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;
## 1   920 572300186 87959 78232126563 11379655
```



`$$572,300,186 =920 \times \beta_0+\beta_1 \times 87,959$$`

`$$78,232,126,563 =\beta_0 \times 87,959+\beta_1 \times 11,379,655$$`

---

### Amsterdam house data

Of course, there are a simpler solution for fitting a **L**inear **M**odel


```r
lm(formula = Price ~ Area, data = amsterdam_house_df)
```

```
## 
## Call:
## lm(formula = Price ~ Area, data = amsterdam_house_df)
## 
## Coefficients:
## (Intercept)         Area  
##     -134910         7918
```

--

How to interpret the results?

1. A house with one additional m^2 in the area would cost € 7918 more

2. If the area would be zero, the price would be - 134910 (both part are impossible, this is just a meaningless extrapolation)

Now we see the estimated coefficients (beta values), but what else can we extract?

---

### Amsterdam house data

The old school (and disadvantageous) method


```r
fit &lt;- lm(formula = Price ~ Area, data = amsterdam_house_df)
summary(fit)
```

```
## 
## Call:
## lm(formula = Price ~ Area, data = amsterdam_house_df)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -1867573  -159054    21513   126639  3220591 
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -134909.9    19145.1  -7.047  3.6e-12 ***
## Area           7917.5      172.1  45.994  &lt; 2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 296700 on 918 degrees of freedom
##   (4 observations deleted due to missingness)
## Multiple R-squared:  0.6974,	Adjusted R-squared:  0.697 
## F-statistic:  2115 on 1 and 918 DF,  p-value: &lt; 2.2e-16
```

---

### Amsterdam house data

The tidy method: {broom}


```r
library(broom)
augment(fit)
```

```
## # A tibble: 920 × 9
##    .rownames  Price  Area .fitted   .resid    .hat  .sigma   .cooksd .std.resid
##    &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;
##  1 1         685000    64 371811.  313189. 0.00142 296650. 0.000795       1.06 
##  2 2         475000    60 340141.  134859. 0.00151 296797. 0.000157       0.455
##  3 3         850000   109 728100.  121900. 0.00115 296804. 0.0000971      0.411
##  4 4         580000   128 878533. -298533. 0.00144 296667. 0.000731      -1.01 
##  5 5         720000   138 957708. -237708. 0.00169 296727. 0.000545      -0.802
##  6 6         450000    53 284719.  165281. 0.00170 296781. 0.000264       0.558
##  7 7         450000    87 553914. -103914. 0.00111 296811. 0.0000684     -0.350
##  8 8         590000    80 498492.   91508. 0.00117 296816. 0.0000557      0.309
##  9 9         399000    49 253049.  145951. 0.00182 296792. 0.000221       0.492
## 10 10        300000    33 126368.  173632. 0.00241 296775. 0.000414       0.586
## # … with 910 more rows
```

---

### Amsterdam house data

The tidy method: {broom}


```r
library(broom)
glance(fit)
```

```
## # A tibble: 1 × 12
##   r.squared adj.r.squared  sigma statistic   p.value    df  logLik    AIC    BIC
##       &lt;dbl&gt;         &lt;dbl&gt;  &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1     0.697         0.697 2.97e5     2115. 1.71e-240     1 -12897. 25800. 25814.
## # … with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt;
```

---

### Amsterdam house data

The tidy method: {broom}


```r
library(broom)
tidy(fit)
```

```
## # A tibble: 2 × 5
##   term        estimate std.error statistic   p.value
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
## 1 (Intercept) -134910.    19145.     -7.05 3.60e- 12
## 2 Area           7918.      172.     46.0  1.71e-240
```

.content-box-green[
The estimated coefficients have a standard error!
]

--

And yes, they have a **confidence interval** as well.


```
## # A tibble: 2 × 7
##   term        estimate std.error statistic   p.value conf.low conf.high
##   &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;
## 1 (Intercept) -134910.    19145.     -7.05 3.60e- 12 -172483.   -97337.
## 2 Area           7918.      172.     46.0  1.71e-240    7580.     8255.
```


---

### Amsterdam house data


```r
coef_df &lt;- tidy(fit, conf.int = TRUE, conf.level = .95)
```

&lt;img src="econometrics1_files/figure-html/unnamed-chunk-23-1.png" width="700px" height="450px" style="display: block; margin: auto;" /&gt;

---

&lt;img src="econometrics1_files/figure-html/unnamed-chunk-24-1.png" width="700px" height="450px" style="display: block; margin: auto;" /&gt;

---

&lt;img src="econometrics1_files/figure-html/unnamed-chunk-25-1.png" width="700px" height="450px" style="display: block; margin: auto;" /&gt;

---

### What is the standard error of the coef?

Let's create a function for the data generating process (DGP), where coefficients can be specified.


```r
dgp &lt;- function(b0 = 100, b1 = 20, n = 100) {
  tibble(x = rnorm(n, sd = 3)) %&gt;% 
    mutate(y = b0 + b1 * x + rnorm(n))
}
```

Let's generate several trajectory with that.


```r
tibble(data = rerun(5, dgp()))
```

```
## # A tibble: 5 × 1
##   data              
##   &lt;list&gt;            
## 1 &lt;tibble [100 × 2]&gt;
## 2 &lt;tibble [100 × 2]&gt;
## 3 &lt;tibble [100 × 2]&gt;
## 4 &lt;tibble [100 × 2]&gt;
## 5 &lt;tibble [100 × 2]&gt;
```


---

### What is the standard error of the coef?


```r
rerun(1e3, dgp()) %&gt;% # 1000 generated trajectory
  tibble(data = .) %&gt;% 
  mutate(
    # the model
    fit = map(data, function(xx) lm(formula = y ~ x, data = xx)), 
    tidied = map(fit, broom::tidy), # coeffients
    estimate = map(tidied, pull, 2), # estimation of the coef
    se = map(tidied, pull, 3), # SE of the coefs
    b0 = map_dbl(estimate, 1),
    b1 = map_dbl(estimate, 2),
    se_b0 = map_dbl(se, 1),
    se_b1 = map_dbl(se, 2),
  ) %&gt;% 
  summarise(
    mean(se_b0), # mean of the estimated SEs
    sd(b0), # sd of the point estimates
    mean(se_b1), # mean of the estimated SEs
    sd(b1), # sd of the point estimates
  )
```

```
## # A tibble: 1 × 4
##   `mean(se_b0)` `sd(b0)` `mean(se_b1)` `sd(b1)`
##           &lt;dbl&gt;    &lt;dbl&gt;         &lt;dbl&gt;    &lt;dbl&gt;
## 1         0.100    0.103        0.0339   0.0325
```

---
### Amsterdam house data

In the table containing the coefficients, a test statistic and a p-value are listed next to each term What hypothesis do they belong to?

--

`$$H_0: \beta_j=0$$`

--

How do we make a decision based on the p-value?

--


.pull-left[
&lt;img src="econometrics_files/meme_lowp.JPG" width="250px" height="250px" style="display: block; margin: auto;" /&gt;
]

.pull-right[
**If the p-value is lower than the significance level (alpha), then we reject the null hypothesis.**

]

--

.blue[And what is the probability of comitting type I error?]

--

Alpha.

---

### Type I error in regression

Let's run the previously created dgp function, but set b1 to 0. How often is the H0 rejected?


```r
tibble(data = rerun(1e3, dgp(b1 = 0))) %&gt;% 
  mutate(
  fit = map(data, function(xx) lm(formula = y ~ x, data = xx)),
  tidied = map(fit, broom::tidy),
  pvalues = map(tidied, pull),
  b1_p = map_dbl(pvalues, 2)
  ) %&gt;% 
  summarise(rate_type1 = sum(b1_p &lt; .05) / n())
```

```
## # A tibble: 1 × 1
##   rate_type1
##        &lt;dbl&gt;
## 1      0.034
```

---

class: inverse, middle, center

# Multivariate regression

---

## Multivariate regression

- Let's say that Y does not only depend on one variable

--

  - For instance, price can be determined based on the area size and the number of rooms
  
  
  `$$Y_i = \beta_0 + \beta_1 \times X_{i, 1} + \beta_2 \times X_{i, 2} + \epsilon_i,$$`
where

`$$X_i,2 = \text{The number of the rooms}$$`
- Sure we could try to "find" the optimal coefficients as presented at the bivariate case, but the number of possibilities (infinity) increased a lot...

- The mathematical background of solving the minimization problem requires the knowledge of algebra

---

## Multivariate regression

.content-box-red[This is not covered by the course!]

`$$\mathbf{y}=\left[\begin{array}{c} y_1 \\ y_2 \\ \vdots \\ y_n \end{array}\right], \quad \mathbf{X}=\left[\begin{array}{ccccc} 1 &amp; x_{11} &amp; x_{21} &amp; \ldots &amp; x_{k 1} \\ 1 &amp; x_{12} &amp; x_{22} &amp; \ldots &amp; x_{k 2} \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 1 &amp; x_{1 n} &amp; x_{2 n} &amp; \ldots &amp; x_{k n} \end{array}\right], \quad \boldsymbol{\beta}=\left[\begin{array}{c} \beta_0 \\ \beta_1 \\ \vdots \\ \beta_k \end{array}\right], \:\:\:\;  \boldsymbol{\varepsilon}=\left[\begin{array}{c} \varepsilon_1 \\ \varepsilon_2 \\ \vdots \\ \varepsilon_n \end{array}\right]$$`

`$$\mathbf{e}^{\mathrm{T}} \mathbf{e}=(\mathbf{y}-\mathbf{X} \hat{\boldsymbol{\beta}})^{\mathrm{T}}(\mathbf{y}-\mathbf{X} \hat{\boldsymbol{\beta}})$$`

`$$\hat{\boldsymbol{\beta}}=\left(\mathbf{X}^{\mathrm{T}} \mathbf{X}\right)^{-1} \mathbf{X}^T \mathbf{y}$$`

---

## Multivariate regression

.pull-left[

Fortunately, our work did not become more difficult in R.
]

.pull-right[
&lt;img src="econometrics_files/meme_byhand.JPG" width="200px" height="200px" style="display: block; margin: auto;" /&gt;

]


```r
fit &lt;- lm(formula = Price ~ Area + Room, data = amsterdam_house_df)

fit
```

```
## 
## Call:
## lm(formula = Price ~ Area + Room, data = amsterdam_house_df)
## 
## Coefficients:
## (Intercept)         Area         Room  
##      -62040         9057       -51009
```


---

## Multivariate regression


```
## 
## Call:
## lm(formula = Price ~ Area + Room, data = amsterdam_house_df)
## 
## Coefficients:
## (Intercept)         Area         Room  
##      -62040         9057       -51009
```

.blue[Can this result be interpreted as if a house has more rooms, it is cheaper?]

--

Of course not.

&lt;img src="econometrics_files/meme_opposite.JPG" width="315px" height="250px" style="display: block; margin: auto;" /&gt;





    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
